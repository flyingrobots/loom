# JITOS Architecture Document — Section 2

## The Process Model: Shadow Working Sets (SWS)

(Grounded in [ADR-0002](../ADR/ADR-0002.md))

---

## 1. The Process Model: Shadow Working Sets

### 2.1 Overview

Every operating system needs a process model—a representation of:

- isolated units of work
- concurrency
- execution context
- state boundaries
- lifecycle semantics

Traditional OSes use:

- processes
- threads
- coroutines
- actors
- fibers
- isolates

Each assumes mutable state and global immediacy of truth.

JITOS rejects these assumptions.

In JITOS, the fundamental unit of execution is the Shadow Working Set (SWS):
an observer-relative, isolated branch of the causal substrate,
where work occurs speculatively before collapsing into the immutable universe.

An SWS is not a thread.
Not a process.
Not a transaction.
Not a workspace.

It is a temporary local universe.

---

### 2.2 Definition

> A Shadow Working Set is:
> 
> A private, isolated projection of the causal graph,
> containing a speculative sequence of events (overlays),
> owned by an agent,
> which collapses into truth through commit.

Formally:

```rust
SWS {
    id: UUID,
    owner: AgentID,
    base_node: NodeID,
    overlays: list<NodeID>,
    virtual_tree_index: map<Path, NodeID>,
    semantic_memory: SemanticGraph,     # optional, nested RMG
    ephemeral_cache: Map,               # destroy on collapse or discard
}
```

Within SWS:

- state is mutable
- execution is isolated
- observations are local
- nothing touches the global substrate

Until collapse.

---

### 2.3 The Purpose of SWS

Shadow Working Sets solve four fundamental problems:

1. Concurrency Without Chaos
SWS isolate work so multiple agents—human or machine—can operate simultaneously without interfering.
2. Speculation Without Mutation
Work happens in a temporary “possible world” until collapse makes it real.
3. Deterministic Collapse
Every SWS collapses into a single new causal event (snapshot node),
ensuring absolute determinism across machines.
4. Unified Human + Machine UX
Humans edit files (macro-level changes).
Machines generate micro-changes (keystrokes, AST rewrites).
Both operate in SWS, differing only by zoom level of their internal RMG.

---

### 2.4 SWS as the Process Abstraction

JITOS does not have:

- threads
- actors
- processes
- green threads
- async tasks

These belong to the era of mutable state.

Instead:

- every unit of computation
- every code edit
- every semantic transformation
- every LLM reasoning session
- every build step
- every CI task
- every agent plan
- every simulation step

is modeled as an SWS.

This provides:

- deterministic boundaries
- clean isolation
- replayability
- semantic provenance
- cross-agent safety
- multi-scale graphs (via RMG)
- trivial time-travel
- perfect reproducibility

No other process model offers these simultaneously.

---

### 2.5 SWS Lifecycle

The lifecycle of an SWS mirrors a quantum interaction:

1. Creation (Branching)
An SWS is created via:

```rust
shadow.create(ref)
```

This clones a snapshot of the universe without materializing files unless required by MH.

2. Mutation (Speculation)

All edits—file diffs, semantic rewrites, provenance annotations—become overlay nodes.
No truth is touched.

3. Analysis (Reflection)

Agents may compute:

- diffs
- builds
- tests
- static analysis
- linting
- reasoning traces

All inside the SWS, in complete isolation.

4. Collapse (Commit)

The SWS collapses to a new snapshot node:

```rust
collapse.commit(sws)
```

This produces:

- snapshot node
- rewrite node(s) if required
- updates to refs
- provenance nodes
- invalidation of SWS

The SWS is destroyed.

5. Discard (Decoherence)

If not needed, the SWS evaporates:

```rust
shadow.discard(sws)
```

No trace remains except ephemeral caches.

No truth impacted.

---

### 2.6 SWS Memory Model (High-Level)

Each SWS contains four memory domains:

1. Virtual Tree Memory (VTM)
The projected (virtual) file tree view.

2. Overlay Graph Memory (OGM)
The structured, graph-based set of speculative edits.

3. Semantic Memory (SM)
Agent reasoning, provenance graphs, AST overlays.

4. Ephemeral Compute Memory (ECM)
Non-persistent caches (lint, build intermediates, etc.).

This will be fully formalized in Section 6 ([ADR-0019](../ADR/ADR-0019.md) integration).

---

### 2.7 Interaction with the Materialized Head

Although MH (filesystem) is an illusionary projection:

- human edits in MH → become overlay nodes in SWS
- machine edits via RPC → become overlay nodes in SWS
- MH never modifies truth
- every human action is mediated through the SWS
- commit re-syncs MH to the new canonical state

This ensures:

- humans get a familiar UX
- machines get precise semantics
- truth remains clean

---

### 2.8 Multi-Agent Behavior

Each agent (human or machine) receives its own SWS unless shared explicitly.

Properties:

- independent worlds
- parallel computation
- deterministic merges
- conflict handled at collapse time
- machine-granular events coexisting with human macro-events

This unifies the workflows of:

- IDEs
- agents
- LLMs
- CI
- distributed workers
- refactoring bots

All treated as co-equal participants in the universe.

---

### 2.9 SWS as the Key to Determinism

Because all work happens in isolated worlds:

- collapse is a pure function
- order of independent SWS collapses does not matter
- provenance is perfect
- no need for locks or global coordination
- failures are easy to retry
- replay is exact

**This is one of the strongest properties of JITOS.**

---

### 2.10 Summary

Shadow Working Sets are:

- the process abstraction of JITOS
- the sandbox for all computation
- the multi-agent concurrency model
- the place where humans and machines meet
- the bridge between micro-scale and macro-scale events
- the crucible where subjective worlds collapse into objective truth

They are the fundamental execution unit of the causal operating system.
