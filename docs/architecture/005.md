Section 5 is epistemology.
It is how humans see the universe.

This is the Materialized Head—
the carefully controlled shadow of the RMG
that lets biological minds edit causal geometry
without losing their sanity.

Let’s carve the veil.

---

# JITOS Architecture Document — Section 5

> The Projection Layer: Materialized Head (MH)

(Grounded in ADR-0005, RFC-0004)

---

## 1. The Projection Layer: Materialized Head

### 5.1 Overview

Materialized Head (MH) is the human-facing, filesystem-like projection of the JITOS universe.

It exists to reconcile two contradictory truths:

Truth

JITOS stores state as an RMG:
a recursive, immutable graph-of-graphs.

Human Perception

Humans expect:

- files
- folders
- directory trees
- text buffers
- POSIX-like interactions
- Git-like workflows
- editors that operate on documents

MH bridges these two worlds.

It is not the substrate.
It is a projection of the substrate
onto a representation humans can manipulate.

MH is the shadow puppetry
that makes causal computing human-compatible.

---

### 5.2 Purpose of Materialized Head

MH exists to:

#### 1. Provide a familiar interface

Humans see:

- a codebase
- files
- folders
- diffs
- merge conflicts

Even though none of these exist in the substrate.

#### 2. Support existing tools

POSIX tools work because MH simulates a filesystem.

#### 3. Bridge SWS and human edits

Any file edit in MH becomes:

- an overlay node
- inside the SWS
- never touching truth directly

#### 4. Allow conceptual batching

Humans don’t commit 30 keystrokes.
Humans commit one meaningful change.

MH provides that conceptual boundary.

#### 5. Protect truth

Truth lives in the immutable RMG.
MH is ephemeral and non-authoritative.

---

### 5.3 MH Architecture

MH consists of four components:

#### 5.3.1 Working Directory Mirror (WDM)

A materialized filesystem tree on disk:

- mirrors projected paths
- lazily created
- lazily updated
- reflects the current snapshot view
- receives user edits
- is ephemeral

#### 5.3.2 Virtual Tree Index (VTI)

A persistent, efficient index mapping:

path → NodeID, size, hash, mtime, flags

This index:

- allows fast git status-like operations
- tracks file states without scanning disk
- supports incremental updates

#### 5.3.3 MH Cache

Caches projections of:

- file contents
- directory structures
- symlink states
- conflict markers

#### 5.3.4 Projection Engine

Translates:

- RMG → filesystem structure
- file edits → SWS overlay nodes
- SWS collapses → filesystem updates
- conflicts → in-file markers

This engine is deterministic.

---

#### 5.4 MH Is Not Truth

Repeat this three times:

> _**MH is a projection.**_
> _**MH is a projection.**_
> _**MH is a projection.**_

It does not:

- store immutable state
- contain authoritative history
- represent causal events
- hold canonical data
- participate in the substrate

It is the cave wall humans observe.

Truth is the RMG.
Reality is the DAG layer.
MH is an interpretation.

In philosophical terms:

MH = appearance
RMG = the thing-in-itself
(Kant would be proud.)

---

### 5.5 MH and Shadow Working Sets

MH interacts with SWS as follows:

1. Human edits file in MH

↓
VTI detects diff
↓
Overlay node created in SWS
↓
OGM (overlay graph memory) updated

2. Human saves

↓
More overlay nodes accumulate

3. Human commits

↓
Collapse applies full RMG region
↓
Snapshot node created
↓
MH mirror updated to new truth

4. MH never mutates the RMG

All MH writes are overlays.
All overlays live inside SWS.
Only collapse modifies truth.

---

### 5.6 Conflict Handling in MH

Conflicts from inversion engine collapse are projected into MH:

- conflict markers inserted
- multi-stage entries stored in VTI
- visualization tools highlight divergent content
- humans resolve through familiar Git-like workflows

Technically:

- conflict is an RMG region
- MH shows the human-scale diff
- resolution is a new RMG region
- collapse produces clean snapshot

MH does not attempt to resolve semantic conflicts.
It merely visualizes them.

---

### 5.7 MH Rebuild, Boot, and Sync Semantics

#### Boot

On boot:

- MH is reconstructed from VTI + the snapshot
- stale files removed
- missing files materialized
- conflicts reloaded
- deterministic regeneration ensures consistency

#### Sync

After pulling new nodes:

- MH is incrementally updated
- only changed files rewritten
- conflicts projected
- human view kept consistent

#### SWS Invalidations

If remote updates invalidate the current SWS:

- MH highlights divergence
- SWS is discarded or rebased
- human receives deterministic feedback

---

### 5.8 MH and RMG: Projection, Not Copy

MH files represent:

- a projection of RMG payload graphs
- rendered at human resolution
- showing text, structure, or other view modes
- NOT duplicating the RMG structure

MH is like:

- rendering SVG from a 3D mesh
- printing a 2D map of a 4D object
- showing a shadow of an RMG hypergraph

MH is the 2D shadow cast by a multidimensional graph.

---

### 5.9 Why MH Is Crucial

MH is absolutely essential because:

✔ JITOS cannot require humans to think in RMG
✔ JITOS must support POSIX tools
✔ JITOS must read/write code at human scale
✔ JITOS must let humans conceptualize one “change”
✔ JITOS must shield humans from micro-events
✔ MH is the bridge between two worlds

In other words:

> MH is the unified human-interface layer of a non-human-native ontology.

Without MH, JITOS is a perfect engine that no human can drive.

---

### 5.10 Summary

Materialized Head:

- is a projection
- is never authoritative
- is fully reproducible
- is incrementally maintained
- maps RMG → files
- maps human edits → SWS overlays
- supports multi-scale computation
- supports deterministic collapse
- supports Git-like UX
- protects causal truth
- bridges humans and the substrate

MH is the veil through which biological minds behold the causal geometry of the JITOS universe.
