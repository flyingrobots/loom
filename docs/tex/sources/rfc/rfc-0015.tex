\section{RFC-0015}\label{rfc-0015}

JIT RFC-0015

JQL---The JIT Query Language (JQL v1.0)

Introspection, Analysis, and Search Over the Causal Universe

Status: Draft**\\
Author: James Ross\\
Contributors: JIT Community\\
Requires:\\
- RFC-0001 Node Identity\\
- RFC-0002 DAG Invariants\\
- RFC-0007 RPC API\\
- RFC-0013 ABI**\\
Start Date: 2025-11-28\\
Target Spec: JITOS v0.x**\\
License: TBD

{\bfseries ?}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Summary
\end{enumerate}

This RFC introduces JQL, the query language for JIT's causal DAG.

JQL is used for:\\
- exploring lineage\\
- searching for nodes\\
- pattern matching\\
- graph traversal\\
- provenance tracing\\
- commit history inspection\\
- shadow analysis\\
- merge ancestry\\
- schema analysis\\
- debugging\\
- introspecting distributed sync\\
- multi-agent coordination\\
- code intelligence\\
- LLM reasoning over historical structure

JQL is to JIT what SQL was to relational data:\\
a unified interface to interrogate truth.

{\bfseries ?}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Motivation
\end{enumerate}

Traditional VCS tools provide:\\
- git log\\
- git grep\\
- git diff\\
- git blame\\
- git show

\ldots but these are:\\
- string-based\\
- file-based\\
- limited\\
- snapshot-centric\\
- not general graph queries\\
- not agent-friendly\\
- not future-oriented\\
- not DAG-native

JIT needs a general DAG query engine.

It must allow:\\
- path queries\\
- ancestor/descendant queries\\
- subgraph slicing\\
- rewrite inspection\\
- conflict queries\\
- node type filtering\\
- metadata predicates\\
- structural pattern matching

In a causal universe,\\
not having a query language is like not having a brain.

{\bfseries ?}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Design Goals
\end{enumerate}

JQL MUST be:

Deterministic

Queries ALWAYS produce the same result for the same DAG.

Purely Functional

Queries do not mutate DAG.

Composable

Queries can be nested, pipelined.

CBOR-native

All expressions map to CBOR structures.

Agent-friendly

Easy for LLMs to generate.

Type-safe

Node types, metadata, ancestors, etc. are known statically.

Efficient

Large DAGs MUST be queryable with indexes + caching.

{\bfseries ?}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  JQL Expression Syntax
\end{enumerate}

JQL has two forms:

4.1 Structural / JSON-like Form (recommended for agents)

\{\\
``select'': ``nodes'',\\
``where'': \{\\
``type'': ``snapshot'',\\
``metadata.author'': ``james'',\\
``payload.contains'': ``function foo''\\
\},\\
``order\_by'': ``logical\_ts DESC'',\\
``limit'': 50\\
\}

This form is:\\
- CBOR-encodable\\
- LLM-friendly\\
- human-readable\\
- structured

4.2 Pipeline Form (Unix-style)

jql nodes\\
\textbar{} where type == snapshot\\
\textbar{} where metadata.author == ``james''\\
\textbar{} grep ``function foo''\\
\textbar{} limit 50

The ``command-line sugar.''

{\bfseries ?}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Core Query Concepts
\end{enumerate}

5.1 Node Sets

nodes\\
snapshots\\
rewrites\\
provenance\\
chunks

5.2 Predicates

type == snapshot\\
author == ``james''\\
timestamp \textgreater{} 17000000\\
payload.contains(``TODO'')

5.3 Graph Traversal

Ancestors:

ancestors(node\_id)\\
ancestors(node\_id, depth=5)

Descendants:

descendants(node\_id)

Path existence:

path\_exists(A, B)

Frontier queries:

frontier()\\
divergence(nodeA, nodeB)

5.4 Subgraph Extraction

subgraph(root=node\_id)\\
subgraph\_between(A, B)

5.5 Pattern Matching

We introduce a simple structural matcher:

match \{\\
parents: {[}X, Y{]},\\
type: ``snapshot'',\\
metadata.branch: ``main''\\
\}

Patterns allow rewriting logic and DPO in the future.

{\bfseries ?}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{5}
\tightlist
\item
  RPC Integration
\end{enumerate}

JQL is executed via:

op: ``jit.search''\\
payload: \{ query: JQLExpression \}

Result:

\{\\
``status'': ``OK'',\\
``nodes'': {[}NodeID\ldots{]},\\
``edges'': optional graph edges,\\
``metadata'': optional info\\
\}

Queries MUST NOT mutate state.

{\bfseries ?}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\tightlist
\item
  Indexing Requirements
\end{enumerate}

For efficiency:\\
- node type index\\
- parent-child index\\
- timestamp index\\
- metadata searchable index\\
- payload search index (optional full-text)

JQL MUST leverage indexes.

If index missing $\rightarrow$\\
JQL MUST fallback to full DAG scan\\
but MUST remain deterministic.

{\bfseries ?}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{7}
\tightlist
\item
  Examples
\end{enumerate}

8.1 Find all snapshots by user

\{\\
``select'': ``nodes'',\\
``where'': \{ ``type'': ``snapshot'', ``metadata.author'': ``james''
\}\\
\}

{\bfseries ?}

8.2 Find all nodes in last 10 minutes

\{\\
``select'': ``nodes'',\\
``where'': \{ ``logical\_ts \textgreater'': now - 600000 \}\\
\}

{\bfseries ?}

8.3 Show the timeline between two commits

\{\\
``select'': ``subgraph\_between'',\\
``args'': \{ ``from'': A, ``to'': B \}\\
\}

{\bfseries ?}

8.4 Pattern match: find all merges

\{\\
``select'': ``nodes'',\\
``where'': \{\\
``type'': ``inversion-rewrite'',\\
``metadata.merge\_type'': ``merge''\\
\}\\
\}

{\bfseries ?}

8.5 Show all SWS created in last hour

\{\\
``select'': ``sws'',\\
``where'': \{ ``created\_ts \textgreater'': now - 3600 \}\\
\}

{\bfseries ?}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{8}
\tightlist
\item
  Security
\end{enumerate}

JQL MUST:\\
- reject dangerous expressions\\
- enforce access control (future)\\
- not reveal private node content (future multi-tenant mode)\\
- never mutate state

{\bfseries ?}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{9}
\tightlist
\item
  Why JQL Matters
\end{enumerate}

Because introspection is the difference between:

FILESYSTEMS\\
(which hide structure)

and

CAUSAL COMPUTING\\
(which is structure).

JQL gives:\\
- LLMs a way to understand the DAG\\
- tools a way to query history\\
- humans a way to explore reality\\
- analysis engines a way to inspect provenance\\
- developers a way to reason about distributed timelines\\
- visualization tools a way to render causal structure

JQL = the language of truth.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\section{\texorpdfstring{\textbf{C\ensuremath{\Omega}MPUTER {\textbullet}
JITOS}}{C\ensuremath{\Omega}MPUTER {\textbullet} JITOS}}\label{cux3c9mputer-jitos}

{\textcopyright} 2025 James Ross {\textbullet} \href{https://flyingrobots.dev}{Flying {\textbullet} Robots} All
Rights Reserved
