---
Status: Draft**
Author: James Ross**
Contributors: JIT Community**
Requires:
- RFC-0001 Node Identity & Encoding
- RFC-0002 DAG Invariants
- RFC-0003 Shadow Working Sets
Start Date: 2025-11-27
Target Spec: JITOS v0.x, TECHSPEC v0.3+
License: Open Source (TBD)**
---

# JIT RFC-0004

## Materialized Head: The Human Projection Layer (MHP v1.0)

---

## 1. Summary

This RFC defines Materialized Head (MH) — JIT’s representation of the global graph as a human-friendly filesystem. It is the illusion layer that provides:

- familiar file I/O
- editor/IDE integration
- compatibility with existing tools
- Git CLI support
- deterministic file reconstruction

Materialized Head is not the true state of the universe —
it is a shadow projection, analogous to Plato’s Cave.

The DAG is reality.
Materialized Head is perception.

---

## 2. Motivation

Humans require:

- files
- directories
- text editors
- terminal-based workflows
- Git operations

But JIT uses:

- nodes
- causal graphs
- rewrites
- SWS overlays
- collapse events

There must be a bridge —
a projection system that maps a high-dimensional causal geometry into a low-dimensional tree of files.

Materialized Head provides this layer without sacrificing:

- determinism
- immutability
- causal truth
- JIT invariants

This is how humans work inside a post-file universe.

---

## 3. Definition

Materialized Head is a filesystem view backed by:

1. Tree Index (LMDB)
2. Working Directory Mirror
3. Metadata Cache
4. Filesystem Watcher
5. Projection Engine

It is tied to a ref (typically HEAD), representing one particular slice of objective reality.

---

## 4. Core Principles

### 4.1 MH is Epistemic

Materialized Head is not truth.
It is a shadow of truth.

Only the DAG carries objective meaning.
MH is a convenient fiction.

---

### 4.2 MH Must Be Deterministic

Given:

- a snapshot node
- the node store
- [RFC-0001](./RFC-0001.md) encoding

Materialized Head **MUST** reconstruct the same file tree everywhere.

---

### 4.3 MH is Incremental

Reconstruction **MUST** be incremental, not full:

- It **MUST** only materialize files that change.
- Unchanged paths **MUST** remain untouched.
- Directory structure **MUST** be updated lazily.

---

### 4.4 MH Is Not Write-Through

Writes to the working directory NEVER mutate reality.

They:

- update MH state
- trigger overlay creation
- enter Shadow Working Sets (SWS)

MH is the input to SWS, not the substrate.

---

### 4.5 MH Must Be Fast

Key performance requirements:

- git status < 20ms
- file edits detected < 10ms
- diff computation < 50ms

Achieved by:

- tree-index caching
- file metadata hashing
- fs watchers
- minimal reconstruction

---

## 5. Tree Index (The Real Data Structure)

The Tree Index is the authoritative representation of the human-facing file system.

It maps:

```rust
path → FileProjection
```

Where:

```rust
FileProjection {
node: NodeID
size: int
hash: blake3-256
mtime: timestamp
flags: bitset (conflict, executable, symlink, etc.)
}
```

Stored in LMDB for durability.

---

## 6. Working Directory Mirror

MH maintains a mirror of the file tree on disk under actual OS files.

Rules:

1. Only modified files are rewritten.
2. Unchanged files are untouched between checkouts.
3. Conflicted files include conflict markers.
4. Deleted files are removed deterministically.
5. Symlinks are restored exactly.

This mirror is the cave wall.

---

## 7. Conflict Semantics

During merges/rebases/inversions:

Materialized Head **MUST** support multi-stage entries:

- `BASE`
- `OURS`
- `THEIRS`
- `RESOLVED`

The index tracks all three, but the filesystem presents textual conflict markers for human resolution.

Example markers (must match Git exactly):

<<<<<<< OURS
...content...
=======
...content...
>>>>>>> THEIRS

After git add, a new file-chunk node is created and the conflict entry becomes `RESOLVED`.

---

## 8. Relationship to SWS

> [!WARNING]
> *This is critical:*

### 8.1 MH serves humans; SWS serves agents.

MH performs:

- file reads
- file writes
- Git CLI operations
- editor interaction

SWS performs:

- ephemeral computation
- speculative operations
- agent-based edits
- automated transformations
- previews

### 8.2 MH must remain consistent with DAG + SWS

When:

- commit occurs
- ref updates
- remote sync
- SWS collapse

MH must merge its view with the new universe state.

This may cause:

- local changes being rebased
- conflicts
- forced refresh
- incremental reconstruction

Consistency **MUST** be maintained at all times.

---

## 9. Filesystem Watcher

MH **MUST** include a watcher that detects:

- file edits
- renames
- deletes
- directory creation

Watcher events become SWS overlays.

MH does NOT “write” to the DAG directly — only SWS can trigger commit.

---

10. Checkout Semantics

During checkout:

1. Retrieve snapshot node
2. Reconstruct tree-index
3. Apply incremental updates to working directory
4. Discard any out-of-date SWS associated with the ref
5. Update MH metadata
6. Update active shadow context

Performance requirement:

- checkout < 150ms on typical repos

---

## 11. Revert & Reset Behavior

Revert:

- create inversion node
- update MH via tree-index
- rewrite filesystem for changed paths

Reset:

- detach MH from previous overlays
- reconstruct tree-index
- remove untracked files if requested

MH must remain deterministic.

---

## 12. Sync Semantics (Remote)

When pulling from remote:

- fetch new snapshot nodes
- merge with MH tree-index
- handle conflicts
- present conflict markers
- ensure deterministic rehydration (RFC-0003)

MH must remain consistent with the updated universe.

---

## 13. Failure & Crash Semantics

Upon crash or abrupt termination:

- MH reconstruction **MUST** be possible from:
- the DAG
- the WAL
- the tree-index

MH is fully recoverable as long as the substrate exists.

Filesystem inconsistencies are ALWAYS repaired during initialization.

---

## 14. Security

MH must obey:

- no SWS can bypass commit
- no direct DAG mutation
- no arbitrary node insertion
- permissions match underlying OS
- signature validations enforced at commit

Filesystem writes are sandboxed to working directory.

---

## 15. Why MH Is Foundational

Materialized Head provides:

- human compatibility
- backwards Git compatibility
- stable user workflows
- deterministic projections
- performance
- reproducibility
- separation of observer frames
- the illusion needed for humans to operate in a post-file world

MH is the human lens through which the geometric universe of JIT becomes visible.

It is the shadow on the wall.

---

# **CΩMPUTER • JITOS** 
© 2025 James Ross • [Flying • Robots](https://flyingrobots.dev)
All Rights Reserved

