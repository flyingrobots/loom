---
title: RFC-0017
date created: Friday, November 28th 2025, 1:20:53 am
date modified: Friday, November 28th 2025, 2:13:47 am
---

# RFC-0017

JIT RFC-0017

Agent Identity & Signing Layer (AIS v1.0)

Identity, Signatures, Attestation & the Provenance of Action

Status: Draft  
Author: James Ross  
Contributors: JIT Community  
Requires:  
	- RFC-0001 Node Identity  
	- RFC-0003 SWS  
	- RFC-0005 Inversion Engine  
	- RFC-0016 Provenance Nodes**  
Start Date: 2025-11-29  
Target Spec: JITOS v0.x**  
License: TBD**

⸻

1. Summary

This RFC defines Agent Identity and Action Signing for the JIT universe.

It provides:  
	- unique agent identifiers  
	- public/private key pairs  
	- signature verification rules  
	- attestation integration  
	- provenance integration  
	- remote sync identity  
	- SWS ownership  
	- collapse authentication  
	- access control primitives

This is the identity substrate for the multi-agent OS JIT is becoming.

⸻

2. Motivation

Agents in JIT can be:  
	- humans  
	- LLMs  
	- CI systems  
	- code transformers  
	- compilers  
	- simulation engines  
	- remote collaborators  
	- toolchains  
	- entire organizations

To ensure:  
	- safety  
	- auditability  
	- trust  
	- reproducibility  
	- governance

…the substrate MUST know:  
	- who acted  
	- what they were authorized to do  
	- which events belong to them  
	- what intent they claimed  
	- whether their semantics are valid

This is identity as physics.

⸻

3. Agent Identity

Each agent MUST have an identity:

AgentID = {  
    id: uuid,  
    public_key: bytes,  
    metadata: {  
        type: “human” | “llm” | “bot” | “system”,  
        label: string,  
        owner: optional string  
    }  
}

Agent types:  
	- human  
	- llm  
	- ci  
	- analysis  
	- formatter  
	- refactorer  
	- supervisor  
	- sync-peer

Optional metadata:  
	- organization  
	- model architecture  
	- LLM embedding  
	- permissions

These identities MUST be registered with JITD.

⸻

4. Signing Model

Every agent MUST cryptographically sign:  
	- every provenance node  
	- every snapshot node they trigger  
	- every rewrite they initiate  
	- every SWS patch  
	- every collapse  
	- every ref update

Signature field:

sig = sign(private_key, NodeID)

Stored in node metadata.

Signatures MUST NOT alter node identity (RFC-0001).

⸻

5. Signature Validation

On ingestion:  
	- signatures MUST verify  
	- invalid signatures MUST reject commit  
	- anonymous commits MAY be allowed if configured  
	- unsigned nodes MUST NOT be accepted unless allowed by policy

Replay MUST verify signatures as well.

⸻

6. Attestation

This layer MAY integrate hardware attestation (future):  
	- TPM / SGX attestation  
	- hardware-backed key material  
	- model fingerprinting for LLM agents

This ensures:  
	- reproducibility of agent behavior  
	- security of automated systems  
	- trust in distributed environments

⸻

7. SWS Ownership

Every Shadow Working Set MUST record:

sws.owner = AgentID

This grants:  
	- per-shadow permissions  
	- per-shadow write rights  
	- per-shadow collapse restrictions  
	- conflict auditing

Only the owner (or authorized agent) may commit a given SWS.

⸻

8. Provenance Integration

Provenance nodes MUST include:

metadata.agent = AgentID  
signature = sign(private_key, hash(provenance_payload))

This unifies:  
	- semantic explanations  
	- thought traces  
	- transformation metadata  
	- runtime parameters  
	- policy compliance

The DAG becomes a signed, immutable narrative of computation.

⸻

9. Remote Sync & Identity

During sync:  
	- peers announce their AgentID  
	- signatures MUST be validated before accepting remote nodes  
	- unauthorized agents MUST NOT update refs  
	- malicious DAG injections must be ignored

Remote peers MUST provide:  
	- public_key  
	- signature on frontier  
	- optional S3 attestations

This prevents:  
	- corrupted node injection  
	- tampered rewrites  
	- forged histories

⸻

10. Permissions Model (Future Integration)

AIS provides the foundation for:  
	- per-branch ACLs  
	- per-node read/write rules  
	- SWS-level permissions  
	- identity scoping  
	- distributed trust graphs

The Security Model (RFC-0020) will build on this.

⸻

11. Why Identity Matters

Because JIT is not a file-based OS.  
It is a universe of agents editing a causal graph.

Without identity:  
	- agents cannot be trusted  
	- provenance is meaningless  
	- LLM reasoning cannot be audited  
	- semantics cannot be attached  
	- rewrite intent cannot be verified  
	- distributed sync is unsafe  
	- malicious commits are invisible  
	- code becomes untraceable

With AIS:  
	- every action is attributable  
	- every event is cryptographically anchored  
	- every edit is accountable  
	- every narrative is validated

This makes JIT suitable for:  
	- enterprise  
	- research  
	- safety-critical systems  
	- collaborative AI development  
	- legal + scientific traceability  
	- secure automation

AIS turns JIT into a serious OS,  
not just a clever paradigm.

⸻

12. Status & Next Steps

We’ve now defined:  
	- Provenance  
	- Identity  
	- Signing  
	- The narrative layer of computation

Next natural RFCs:  
	- RFC-0018—Causal Garbage Isolation (NOT deletion)  
	- RFC-0019—SWS Memory Model  
	- RFC-0020—Security Model  
	- RFC-0021—Multi-Universe Federation Protocol (the super advanced one)

---

# **CΩMPUTER • JITOS** 
© 2025 James Ross • [Flying • Robots](https://flyingrobots.dev)
All Rights Reserved

