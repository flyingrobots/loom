---
Status: Draft
Author: James Ross
Contributors: JIT Community
Requires:
- RFC-0001: Nodes
- RFC-0002: DAG Invariants
- RFC-0003: SWS
- RFC-0004: Materialized Head
- RFC-0005: Inversion Engine
- RFC-0006: WAL & Replay
Start Date: 2025-11-28
Target Spec: JITOS v0.x
License: TBD
---

# JIT RFC-0007

## JIT RPC API (JRAPI v1.0)

### The Syscall Layer of the Inversion Kernel

---

## 1. Summary

This RFC defines the canonical RPC API for interacting with the JIT Kernel (GITD).

This API replaces:

- POSIX syscalls
- Git plumbing commands
- ad hoc filesystem interactions
- shell-based workflows

…with a unified, structured, typed, agent-friendly interface.

The RPC API provides:

- Shadow Working Set lifecycle
- DAG operations
- collapse/commit interface
- Materialized Head sync
- Git protocol abstraction
- sync and replication primitives
- introspection and query semantics

This is the ABI of the causal universe.

---

## 2. Motivation

The Inversion Kernel is not a file-based OS.

It cannot expose:

- `open()`
- `read()`
- `write()`
- `fork()`
- `exec()`

These make no sense in a causal DAG.

Instead, JIT must expose operations that manipulate:

- nodes
- shadows
- worldlines
- projections
- rewrites
- collapse events
- provenance
- time

This necessitates a new syscall layer: JIT RPC.

---

## 3. Transport

RPC MUST support:

- Unix domain sockets (local)
- TCP+TLS (remote)
- QUIC (optional future transport)

Serialization MUST be:

- canonical CBOR (for determinism)

---

4. RPC Structure

Every RPC request:

```json
{
  "op": "string",
  "payload": CBOR-encoded struct,
  "ts": client_logical_clock
}
```

Every RPC response:

```json
{
  "status": "OK" | "ERR",
  "result": CBOR-encoded struct,
  "error": optional string
}
```

Logical timestamps MUST propagate into SWS and WAL ordering.

---

## 5. RPC Categories

We define RPCs in six categories:

1. Shadow Working Set (SWS) API
2. Collapse / Commit API
3. DAG Access API
4. Projection (MH) API
5. Git Protocol Facade API
6. Sync & Replication API
7. Introspection & Query API

Let’s detail each.

---

## 6. Shadow Working Set API

These are the “process control” syscalls of the JIT OS.

### 6.1 shadow.create

op: "shadow.create"
payload: { ref: string }
result: { id: uuid, base_node: NodeID }

Creates a new Shadow Working Set anchored to ref.

---

### 6.2 shadow.apply_patch

op: "shadow.apply_patch"
payload: { id: uuid, patch: PatchData }
result: { updated: bool }

Applies an edit within the SWS.
Diff → chunk → overlay nodes.

---

### 6.3 shadow.diff

op: "shadow.diff"
payload: { id: uuid, ref: string }
result: { diff: DiffData }

Computes difference between SWS and another snapshot or ref.

---

### 6.4 shadow.status

op: "shadow.status"
payload: { id: uuid }
result: { overlays: list<NodeID>, conflicts: list<Conflict> }

Local SWS state reporting.

---

### 6.5 shadow.discard

op: "shadow.discard"
payload: { id: uuid }
result: {}

Destroys a shadow.
Zero side effects.

---

## 7. Collapse / Commit API

Collapse is how shadows become real.

### 7.1 collapse.commit

op: "collapse.commit"
payload: { id: uuid }
result: {
  snapshot: NodeID,
  rewrite: optional NodeID,
  conflicts: list<Conflict>,
  updated_ref: string
}

Triggers collapse.
If conflicts cannot be deterministically resolved, commit MUST fail.

---

### 7.2 collapse.validate

op: "collapse.validate"
payload: { id: uuid }
result: { ok: bool, errors: list<string> }

Checks whether a commit would succeed.

---

# 8. DAG Access API

Direct substrate queries (read-only).

### 8.1 dag.get_node

op: "dag.get_node"
payload: { id: NodeID }
result: NodeData


---

### 8.2 dag.get_parents

op: "dag.get_parents"
payload: { id: NodeID }
result: { parents: list<NodeID> }


---

### 8.3 dag.lineage

op: "dag.lineage"
payload: { id: NodeID, depth: int }
result: { ancestors: list<NodeID> }


---

### 8.4 dag.subgraph

```
op: "dag.subgraph"
payload: { root: NodeID }
result: { nodes: list<Node>, edges: list<Edge> }
```


---

##9. Projection (Materialized Head) API

MH is the human projection of truth.

### 9.1 mh.checkout

op: "mh.checkout"
payload: { ref: string }
result: { root: NodeID, files: list<FileProjection> }

Performs incremental reconstruction.

---

### 9.2 mh.status

op: "mh.status"
payload: {}
result: { changes: list<PathStatus> }

Simplified status for editors/IDE integrations.

---

### 9.3 mh.read_file

op: "mh.read_file"
payload: { path: string }
result: { content: bytes }

MH → SWS projection.

---

## 10. Git Protocol Facade API

For backward compatibility.

### 10.1 git.upload_pack

op: "git.upload_pack"
payload: { wants: list<NodeID>, haves: list<NodeID> }
result: GitPackData


---

### 10.2 git.receive_pack

op: "git.receive_pack"
payload: GitObjectSet
result: { updated: bool, rewrites: list<NodeID> }

JIT LOSSES NO FIDELITY HERE.

---

## 11. Sync & Replication API

Distributed computing, remote sync.

### 11.1 sync.pull

op: "sync.pull"
payload: { remote: string, ref: string }
result: { nodes: list<NodeID>, updates: list<RefUpdate> }


---

### 11.2 sync.push

op: "sync.push"
payload: { remote: string, ref: string }
result: { accepted: bool }


---

### 11.3 sync.missing_nodes

op: "sync.missing_nodes"
payload: { remote_frontier: list<NodeID> }
result: { missing: list<NodeID> }


---

## 12. Introspection & Query API

For analytics, tools, LLMs, explorers, etc.

### 12.1 jit.info

op: "jit.info"
payload: {}
result: {
  dag_size: int,
  node_count: int,
  head: NodeID,
  sws_active: int,
  mh_state: MHInfo
}


---

### 12.2 jit.search

op: "jit.search"
payload: { query: QueryExpr }
result: { matches: list<NodeID> }


---

### 12.3 jit.graphviz

```
op: "jit.graphviz"
payload: { root: NodeID }
result: { dotfile: string }
```

Enables visualization tooling.

---

## 13. Error Model

All RPCs MUST return:

- status: ERR
- standardized error codes
- optional human-readable message

> [!critical]
> Errors MUST NEVER corrupt the DAG or MH.

---

## 14. Security

RPC must enforce:

- per-SWS isolation
- signature validation
- ref protections
- access control (future)
- secure transport

---

## 15. Why This API Matters

This is the syscall interface of the new OS.

It:

- abstracts away direct file I/O
- provides a stable ABI for agents
- lets external systems integrate with JIT
- supports introspection & analysis
- enables distributed correctness
- replaces POSIX, Git plumbing, and half of Unix’s syscall table
- makes JITOS a real, buildable, extensible kernel

This is where the system becomes usable.

---

## 16. Status & Next Steps

### Next RFC:

[RFC-0008](./RFC-0008.md) — Message Plane Integration (Distributed coordination & SWS orchestration)

---

# **CΩMPUTER • JITOS** 
© 2025 James Ross • [Flying • Robots](https://flyingrobots.dev)
All Rights Reserved

