---
title: RFC-0015
date created: Friday, November 28th 2025, 1:17:05 am
date modified: Friday, November 28th 2025, 2:12:34 am
---

# RFC-0015

JIT RFC-0015

JQL—The JIT Query Language (JQL v1.0)

Introspection, Analysis, and Search Over the Causal Universe

Status: Draft**  
Author: James Ross  
Contributors: JIT Community  
Requires:  
	- RFC-0001 Node Identity  
	- RFC-0002 DAG Invariants  
	- RFC-0007 RPC API  
	- RFC-0013 ABI**  
Start Date: 2025-11-28  
Target Spec: JITOS v0.x**  
License: TBD

⸻

1. Summary

This RFC introduces JQL, the query language for JIT’s causal DAG.

JQL is used for:  
	- exploring lineage  
	- searching for nodes  
	- pattern matching  
	- graph traversal  
	- provenance tracing  
	- commit history inspection  
	- shadow analysis  
	- merge ancestry  
	- schema analysis  
	- debugging  
	- introspecting distributed sync  
	- multi-agent coordination  
	- code intelligence  
	- LLM reasoning over historical structure

JQL is to JIT what SQL was to relational data:  
a unified interface to interrogate truth.

⸻

2. Motivation

Traditional VCS tools provide:  
	- git log  
	- git grep  
	- git diff  
	- git blame  
	- git show

…but these are:  
	- string-based  
	- file-based  
	- limited  
	- snapshot-centric  
	- not general graph queries  
	- not agent-friendly  
	- not future-oriented  
	- not DAG-native

JIT needs a general DAG query engine.

It must allow:  
	- path queries  
	- ancestor/descendant queries  
	- subgraph slicing  
	- rewrite inspection  
	- conflict queries  
	- node type filtering  
	- metadata predicates  
	- structural pattern matching

In a causal universe,  
not having a query language is like not having a brain.

⸻

3. Design Goals

JQL MUST be:

Deterministic

Queries ALWAYS produce the same result for the same DAG.

Purely Functional

Queries do not mutate DAG.

Composable

Queries can be nested, pipelined.

CBOR-native

All expressions map to CBOR structures.

Agent-friendly

Easy for LLMs to generate.

Type-safe

Node types, metadata, ancestors, etc. are known statically.

Efficient

Large DAGs MUST be queryable with indexes + caching.

⸻

4. JQL Expression Syntax

JQL has two forms:

4.1 Structural / JSON-like Form (recommended for agents)

{  
  “select”: “nodes”,  
  “where”: {  
    “type”: “snapshot”,  
    “metadata.author”: “james”,  
    “payload.contains”: “function foo”  
  },  
  “order_by”: “logical_ts DESC”,  
  “limit”: 50  
}

This form is:  
	- CBOR-encodable  
	- LLM-friendly  
	- human-readable  
	- structured

4.2 Pipeline Form (Unix-style)

jql nodes  
 | where type == snapshot  
 | where metadata.author == “james”  
 | grep “function foo”  
 | limit 50

The “command-line sugar.”

⸻

5. Core Query Concepts

5.1 Node Sets

nodes  
snapshots  
rewrites  
provenance  
chunks

5.2 Predicates

type == snapshot  
author == “james”  
timestamp > 17000000  
payload.contains(“TODO”)

5.3 Graph Traversal

Ancestors:

ancestors(node_id)  
ancestors(node_id, depth=5)

Descendants:

descendants(node_id)

Path existence:

path_exists(A, B)

Frontier queries:

frontier()  
divergence(nodeA, nodeB)

5.4 Subgraph Extraction

subgraph(root=node_id)  
subgraph_between(A, B)

5.5 Pattern Matching

We introduce a simple structural matcher:

match {  
  parents: [X, Y],  
  type: “snapshot”,  
  metadata.branch: “main”  
}

Patterns allow rewriting logic and DPO in the future.

⸻

6. RPC Integration

JQL is executed via:

op: “jit.search”  
payload: { query: JQLExpression }

Result:

{  
  “status”: “OK”,  
  “nodes”: [NodeID…],  
  “edges”: optional graph edges,  
  “metadata”: optional info  
}

Queries MUST NOT mutate state.

⸻

7. Indexing Requirements

For efficiency:  
	- node type index  
	- parent-child index  
	- timestamp index  
	- metadata searchable index  
	- payload search index (optional full-text)

JQL MUST leverage indexes.

If index missing →  
JQL MUST fallback to full DAG scan  
but MUST remain deterministic.

⸻

8. Examples

8.1 Find all snapshots by user

{  
  “select”: “nodes”,  
  “where”: { “type”: “snapshot”, “metadata.author”: “james” }  
}

⸻

8.2 Find all nodes in last 10 minutes

{  
  “select”: “nodes”,  
  “where”: { “logical_ts >”: now - 600000 }  
}

⸻

8.3 Show the timeline between two commits

{  
  “select”: “subgraph_between”,  
  “args”: { “from”: A, “to”: B }  
}

⸻

8.4 Pattern match: find all merges

{  
  “select”: “nodes”,  
  “where”: {  
    “type”: “inversion-rewrite”,  
    “metadata.merge_type”: “merge”  
  }  
}

⸻

8.5 Show all SWS created in last hour

{  
  “select”: “sws”,  
  “where”: { “created_ts >”: now - 3600 }  
}

⸻

9. Security

JQL MUST:  
	- reject dangerous expressions  
	- enforce access control (future)  
	- not reveal private node content (future multi-tenant mode)  
	- never mutate state

⸻

10. Why JQL Matters

Because introspection is the difference between:

FILESYSTEMS  
(which hide structure)

and

CAUSAL COMPUTING  
(which is structure).

JQL gives:  
	- LLMs a way to understand the DAG  
	- tools a way to query history  
	- humans a way to explore reality  
	- analysis engines a way to inspect provenance  
	- developers a way to reason about distributed timelines  
	- visualization tools a way to render causal structure

JQL = the language of truth.

---

# **CΩMPUTER • JITOS** 
© 2025 James Ross • [Flying • Robots](https://flyingrobots.dev)
All Rights Reserved

