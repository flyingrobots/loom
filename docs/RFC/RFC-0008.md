---
Status: Draft
Author: James Ross
Contributors: JIT Community
Requires:
- RFC-0001 Node Identity
- RFC-0002 DAG Invariants
- RFC-0003 SWS Semantics
- RFC-0005 Inversion Engine
- RFC-0007 RPC API**
Start Date: 2025-11-28
Target Spec: JITOS v0.x
License: Open Source (TBD)
---

# JIT RFC-0008

## Message Plane Integration (MPI v1.0)

### Distributed Coordination for Shadow-Based Causal Computing

---

## 1. Summary

This RFC defines how JIT integrates with a Message Plane —
a distributed, topic-based communication layer used for:

- Shadow Working Set orchestration
- multi-agent collaboration
- patch flow
- remote execution
- distributed builds
- workflow pipelines
- collaborative editing
- agent swarming
- distributed computation

The Message Plane unifies event sourcing, actor systems, and controller loops, but grounded in causal DAG physics.

JIT does not rely on the MP for correctness or determinism —
but uses it for coordination, dispatch, and parallelism.

---

## 2. Motivation

Why do we need a Message Plane?

Because the modern universe of computation is:

- multi-agent
- distributed
- asynchronous
- latency-bound
- partially observable
- concurrency-rich

And Shadow Working Sets are isolated ephemeral worlds that must be:

- created
- mutated
- resolved
- collapsed
- synchronized
- coordinated

The Message Plane enables:

- remote agent editing
- shared tasks
- distributed merges
- CI pipelines
- “agent swarms”
- LLM-based code modification
- structured patch flow

It is the coordination fabric,
not the truth fabric.

The DAG is truth.
The MP is conversation.

---

3. Architectural Role

The Message Plane is:
- stateless (mostly)
- ephemeral
- pub/sub based
- non-authoritative
- advisory

GITD retains all authority.
Message Plane cannot mutate the universe.

Instead, MP delivers:
- shadow commands
- patch proposals
- commit requests
- merge directives
- execution jobs
- remote control messages

---

4. Message Plane Concepts

Topic

A logical channel for message exchange.

Subscriber

Agent or local service listening on a topic.

Publisher

Agent or subsystem sending data into a topic.

Payload

CBOR-encoded messages.

Transport

Message Plane MAY use:
- NATS
- Kafka
- Redis Streams
- MQTT
- Custom JIT-native layer
- etc.

MP is agnostic; RPC + invariants keep truth consistent.

---

5. SWS Topics (Core Model)

Each Shadow Working Set has its own topic namespace:

jit.sws.<id>.patch
jit.sws.<id>.analyze
jit.sws.<id>.commit
jit.sws.<id>.discard
jit.sws.<id>.status

These enable agent swarming:
- LLMs editing the same shadow in coordinated fashion
- CI tools analyzing patches
- formatters, linters, compilers updating overlays
- “bots” pushing semantic changes

Invariant:

MP interactions MUST NOT directly write to DAG.

All changes must go through:

shadow.apply_patch
shadow.commit

via RPC.

---

6. Global Kernel Topics

GITD itself uses global topics:

jit.kernel.events
jit.kernel.sync
jit.kernel.ref_updates
jit.kernel.sws_lifecycle

These act as kernel notifications:

- SWS created/destroyed
- commit collapse events
- ref updates
- distributed sync start/finish

These are for GUIs, dashboards, logs, orchestrators.

---

7. Message Payloads

MP messages MUST be CBOR-encoded and MUST include:

{
  "sender": agent_id,
  "ts": logical_clock,
  "payload": {...}
}

Why?

- deterministic ordering
- replay
- causal tracing
- provenance

Agents are first-class citizens.

---

8. Ordering Guarantees

The MP provides:

Per-topic FIFO ordering

- In each topic, messages preserve ordering
- No guarantee across different topics

Delivery Semantics

JIT requires at-least-once delivery.

Why?

- collapse/commit is idempotent
- patch operations are idempotent under [RFC-0003](./RFC-0003.md)
- ordering guarantees come from causal invariants, not MP

### Idempotence

All MP messages MUST be idempotent at RPC layer.

If the same message arrives twice → same effect.

---

## 9. SWS Coordination Patterns

### 9.1 Multi-Agent Editing

Example flow:

1. Agent A publishes patch
2. Agent B publishes patch
3. SWS receives both
4. RPC layer applies patches in deterministic order
5. Conflicts resolved locally
6. Optional collapse

### 9.2 Agent Swarms

Topic:

```rust
jit.sws.<id>.analyze
```

Multiple agents run:

- static analysis
- semantic analysis
- build/test
- refactoring
- documentation generation
- risk scoring

All contribute overlays.

### 9.3 Human + Agent Co-Editing

Human edits → FS watcher → SWS overlay
Agent edits → MP patch → SWS overlay

Equal footing.

---

## 10. Distributed Sync

Message Plane carries:

- remote announcements
- frontier messages
- availability signals
- ephemeral state

But all truth is validated and written through RPC → WAL → DAG.

MP coordinates;
GITD commits.

---

## 11. MP and Conflict Convergence

MP can generate race conditions — good.

GITD must handle:

- multiple patches
- conflicting edits
- concurrent SWS updates
- distributed overlay batching
- delayed collapse

Through deterministic resolution rules in:

- [RFC-0003](./RFC-0003.md) (SWS)
- [RFC-0005](./RFC-0005.md) (Inversion Engine)

MP stimulates concurrency.
The kernel arbitrates.

This is how emergent behavior appears.

---

## 12.  Fault Tolerance

MP is advisory, so failure is:

- non-fatal
- non-corrupting
- recoverable

If MP crashes:

- SWS and DAG remain intact
- WAL ensures time/log consistency
- GITD performs eventual convergence

MP MUST be restartable without loss of correctness.

---

## 13. Security

MP MUST support:

- agent identity
- signatures (optional)
- topic-level ACLs
- replay detection
- rate limiting
- sandboxing

SWS IDs MUST NOT be guessable.

MP cannot impersonate GITD.

---

## 14. Why MP Is Crucial

Because JIT is:

- multi-agent
- distributed
- post-file
- observer-relative
- shadow-native

MP enables:

- orchestration
- automation
- parallel editing
- code swarms
- semantic pipelines
- build observers
- remote agent fleets
- consensus-driven transforms

MP is the nervous system to the DAG’s spacetime and the Inversion Engine’s physics.

Without the MP:

- no agent cooperation
- no swarming
- no distributed verification
- no real-time collaboration
- no event-driven automation

With it?

JIT becomes a living computational universe.

---

## 15. Status & Next Steps

### Next RFC:

[RFC-0009](./RFC-0009.md) — Storage Tiering & Rehydration (The cold/hot/warm substrate dynamics)

---

# **CΩMPUTER • JITOS** 
© 2025 James Ross • [Flying • Robots](https://flyingrobots.dev)
All Rights Reserved

