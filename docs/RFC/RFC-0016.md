---
title: RFC-0016
date created: Friday, November 28th 2025, 1:19:10 am
date modified: Friday, November 28th 2025, 2:13:26 am
---

# RFC-0016

 RFC-0016

JIT RFC-0016

Semantic Provenance Nodes (SPN v1.0)

Causal Narratives, Scientific Lineage & the Ontology of “Why”

Status: Draft  
Author: James Ross  
Contributors: JIT Community  
Requires:  
	- RFC-0001 Node Identity  
	- RFC-0002 DAG Invariants  
	- RFC-0005 Inversion Engine  
	- RFC-0015 JQL  
Start Date: 2025-11-29  
Target Spec: JITOS v0.x  
License: TBD**

⸻

1. Summary

This RFC defines the Semantic Provenance Node (SPN)—
a special node type in the causal DAG that encodes WHY something happened.

While:  
	- snapshot nodes represent what happened  
	- rewrite nodes represent how it changed  
	- chunk nodes represent literal content  
	- metadata represents when and who

provenance nodes represent WHY.

These nodes attach semantic meaning, intent, context, method, reasoning, and description to events in the causal universe.

This is what makes JIT not just a version-control system,  
but a computational narrative engine.

⸻

2. Motivation

In computing, we rarely answer why something happened.  
Git tells you:  
	- who did it  
	- when they did it  
	- what changed

…but Git CANNOT tell you:  
	- why a change was made  
	- what experiment it belonged to  
	- what assumptions were involved  
	- what tools produced it  
	- what tasks it relates to  
	- what model or dataset it depended upon  
	- what semantic transformation occurred

JIT must support:  
	- scientific reproducibility  
	- ML provenance  
	- CI/CD traceability  
	- distributed agent reasoning  
	- semantic code modifications  
	- meta-information about rewrites  
	- alignment & safety auditing  
	- academic workflows  
	- simulation lineage

Provenance is the missing piece.

⸻

3. Definition

A Provenance Node is a causal event that encodes semantic information:

ProvenanceNode {  
    type: “provenance”,  
    parents: list<NodeID>,  
    metadata: {  
        agent: AgentID,  
        created_ts: u64,  
        category: string,  
        description: string,  
        tags: list<string>,  
        properties: map<string, CBOR-value>  
    },  
    payload: bytes # structured CBOR semantic content  
}

Valid categories:  
	- “experiment”  
	- “analysis”  
	- “transformation”  
	- “reasoning”  
	- “evidence”  
	- “annotation”  
	- “intent”  
	- “constraint”  
	- “summary”  
	- “runtime”  
	- “explanation”  
	- “tool-action”  
	- “model-run”

The system is extensible.

⸻

4. Attachments & Linkages

Provenance nodes MUST attach to:  
	- snapshot nodes  
	- rewrite nodes  
	- chunk nodes  
	- other provenance nodes  
	- shadow working sets (via references, not causal parents)

This models a semantic graph layered atop the causal graph.

A graph of meaning atop a graph of events.

⸻

5. Semantic Payloads

Payload examples:

5.1 Natural Language Reasoning

“payload”: {  
  “explanation”: “Refactored module X for performance.”,  
  “context”: “Agent performed structure analysis.”,  
  “risk”: “low”  
}

5.2 LLM Thought Trace

“payload”: {  
  “thought”: “…longform reasoning…”  
}

5.3 Experiment Details

“payload”: {  
  “hyperparameters”: {…},  
  “dataset_version”: “v3.2”,  
  “runtime_env”: {…}  
}

5.4 Semantic Transformation Descriptor

“payload”: {  
  “transformation”: “rename_method”,  
  “from”: “foo”,  
  “to”: “bar”  
}

JIT does NOT interpret meaning;  
it stores meaning.

The meaning becomes part of the universe.

⸻

6. Provenance Rules

6.1 Semantic Information MUST NOT affect node identity

No causal invariants changed by provenance.

6.2 Provenance nodes MUST be immutable

Like all nodes.

6.3 Provenance MAY be attached retroactively

Parents MUST be valid DAG nodes  
but parents may precede creation.

6.4 Provenance MUST NOT affect collapse

Collapse uses:  
	- chunk nodes  
	- rewrite nodes  
	- snapshot nodes

Provenance is advisory/semantic only.

6.5 Provenance MUST support multi-agent authors

Metadata MUST record:  
	- agent  
	- tool  
	- human  
	- LLM  
	- system task

Transparent lineage.

⸻

7. JQL Integration

JQL MUST support:

select provenance  
where category == “experiment”

Or:

match {  
  type: “provenance”,  
  metadata.agent: “agent-34”,  
  tags: [“autofix”]  
}

This allows:  
	- reasoning trace queries  
	- semantic filtering  
	- experiment lineage retrieval  
	- conceptual graph querying  
	- model provenance reconstruction

This is crucial for scientific/ML workflows.

⸻

8. Tooling Integration

Tools MUST be able to generate provenance nodes:  
	- LLMs annotate their reasoning  
	- CI documents test runs  
	- build systems attach metadata  
	- simulation engines attach parameters  
	- compilers attach analysis  
	- editors attach semantic actions

This creates a layer of explanation above all computation.

⸻

9. Why Provenance Nodes Matter

Because they enable:

Scientific Reproducibility

Every run, every transformation, every parameter stored forever.

Safe Automated Code Editing

Agents can justify edits.

Auditable AI Systems

LLMs can record thought traces.

Workflow Traceability

Every action in CI/CD is captured.

Semantic Code Intelligence

Refactoring becomes meaningful, not textual.

Alignment & Monitoring

We can track the intent behind agent actions.

Differentiable Programming of Reality

The DAG becomes a semantic universe, not just a structural one.

This is a new capability for computing.

⸻

10. Status & Next Steps

Now we can build:  
	- Semantic execution  
	- Reasoning engines  
	- Visualization tools  
	- Reproducible simulation systems  
	- Scientific JIT workflows  
	- LLM supervision layers  
	- “auditability by construction” pipelines

Next recommended RFCs:  
	- RFC-0017—Agent Identity & Signing Layer  
	- RFC-0018—Causal Garbage Isolation  
	- RFC-0019—SWS Memory Model  
	- RFC-0020—Security & Permissions

---

# **CΩMPUTER • JITOS** 
© 2025 James Ross • [Flying • Robots](https://flyingrobots.dev)
All Rights Reserved

