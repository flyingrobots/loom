JIT RFC-0013

JIT Syscall ABI (JS-ABI v1.0)

Binary Encoding, Wire Format, and Low-Level Interface to the Inversion Kernel

Status: Draft**
Author: James Ross
Contributors: JIT Community
Requires:
	•	RFC-0007 (JIT RPC API)
	•	RFC-0001, RFC-0002, RFC-0006 (Identity, Invariants, WAL)**
Start Date: 2025-11-28
Target Spec: JITOS v0.x**
License: TBD**

⸻

1. Summary

This RFC defines the binary interface and wire protocol that:
	•	the CLI
	•	editors
	•	agents
	•	remote daemons
	•	plugins
	•	runtime components
	•	and future languages/tools

use to communicate with GITD —
the JIT Inversion Kernel.

This ABI is to JIT what:
	•	syscalls are to Linux
	•	the VM ABI is to the JVM
	•	the wire protocol is to Git
	•	the POSIX API is to Unix

BUT:

Instead of manipulating files or memory,
the JIT ABI manipulates:
	•	nodes
	•	shadows
	•	causal structure
	•	time (via WAL)
	•	projection layers
	•	ref pointers
	•	storage tiers
	•	agent contexts

This is the low-level truth of the JIT universe.

⸻

2. Motivation

To ensure:
	•	cross-language compatibility
	•	cross-platform determinism
	•	wire-stable interoperability
	•	long-term future-proofing
	•	consistent semantics
	•	binary safety
	•	remote invocation
	•	agent swarm coordination

…JIT must define a precise, binary-level ABI.

This ABI becomes the universal interface contract for all tools that speak JIT.

It must be:
	•	stable
	•	extensible
	•	secure
	•	deterministic
	•	canonical
	•	easy to parse
	•	impossible to misinterpret

This is the heart of interoperability.

⸻

3. Transport Layer

3.1 Supported Transports
	•	Unix domain sockets (primary)
	•	TCP + TLS (remote)
	•	QUIC (optional/future)

All transports MUST implement:
	•	binary framing
	•	capability negotiation
	•	versioning
	•	checksums

⸻

4. Message Framing

Every message consists of:

+----------------------------------+
| MAGIC (4 bytes): "JIT!"          |
+----------------------------------+
| VERSION (u16)                    |
+----------------------------------+
| FLAGS (u16)                      |
+----------------------------------+
| LENGTH (u32)                     |
+----------------------------------+
| PAYLOAD (bytes[LENGTH])          |
+----------------------------------+
| CHECKSUM (blake3-256, 32 bytes)  |
+----------------------------------+

Notes:
	•	MAGIC identifies valid packets
	•	VERSION = major.minor (encoded 0xMMmm)
	•	FLAGS = compression, streaming, async markers
	•	LENGTH = byte length of CBOR payload
	•	PAYLOAD = canonical CBOR
	•	CHECKSUM = BLAKE3 hash

If checksum fails → packet rejected.

⸻

5. Operation Encoding

Inside the payload:

{
  "op": string,
  "ts": logical_timestamp,
  "payload": CBOR-encoded struct
}

Operation names MUST match RFC-0007.

⸻

6. Error Codes

JIT MUST standardize error codes:

E_INVALID_OP          = 1
E_BAD_PAYLOAD         = 2
E_CHECKSUM_FAIL       = 3
E_INVARIANT_VIOLATION = 4
E_NOT_FOUND           = 5
E_REF_CONFLICT        = 6
E_REWRITE_ERROR       = 7
E_ACCESS_DENIED       = 8
E_SWS_INVALID         = 9
E_COLLAPSE_FAIL       = 10
E_INTERNAL_ERROR      = 500

Errors MUST NOT leak kernel-internal details
and MUST preserve determinism.

⸻

7. Capability Negotiation

At connection start:

client → server:
{
  "op": "handshake",
  "capabilities": [strings],
  "client_version": u16
}

Server responds:

server → client:
{
  "status": "OK",
  "server_version": u16,
  "capabilities": [strings],
  "session_id": uuid
}

Capabilities MUST include:
	•	compression formats
	•	extension ops
	•	streaming support
	•	future-proof features

⸻

8. Compression

Payloads MAY be compressed.

Supported:
	•	none
	•	zstd
	•	gzip
	•	Brotli (optional)

Compression MUST NOT affect semantics.

Compression flags stored in FLAGS.

⸻

9. Streaming Mode

Certain operations (e.g., sync.pull) may require streaming.

Streaming packets use:
	•	FLAG_STREAM_BEGIN
	•	FLAG_STREAM_CONT
	•	FLAG_STREAM_END

Streaming MUST maintain:
	•	order
	•	integrity
	•	checksum per packet

This is essential for large subgraph transfers.

⸻

10. ABI Stability Guarantees

JIT MUST guarantee:
	•	Forward compatibility:
Old clients → new servers
MUST NOT break functionality.
	•	Backward compatibility:
New clients → old servers
MUST fallback gracefully.
	•	Deterministic decoding:
No ambiguous CBOR structures allowed.
	•	Future extensions:
New ops MUST not break existing tooling.

This ABI must remain stable across:
	•	architectures
	•	OSes
	•	compilers
	•	languages
	•	time

⸻

11. Security Layer

ABI-level security MUST include:
	•	TLS for TCP
	•	agent identity tokens
	•	SWS-scoped authorization
	•	optional signed messages
	•	replay attack prevention

Session IDs MUST be checked
with logical timestamp progression.

⸻

12. Why ABI Matters

Because:

Without ABI →
agents can’t talk to JIT.
IDEs can’t talk to JIT.
Git can’t talk to JIT.
CI can’t talk to JIT.
Remote sync can’t happen.
Distributed systems fail.
Future tools fracture.

With ABI →
JIT becomes a platform,
not a tool.

This is the layer that makes JIT:
	•	universal
	•	programmable
	•	language-independent
	•	future-proof

Unix had syscalls.
The Web had HTTP.
Git had packfile protocols.
JIT has JS-ABI.

⸻

---

# **CΩMPUTER • JITOS** 
© 2025 James Ross • [Flying • Robots](https://flyingrobots.dev)
All Rights Reserved

