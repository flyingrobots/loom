---
Status: Draft**
Author: James Ross**
Contributors: JIT Community**
Requires:
- RFC-0001 Node Identity
- RFC-0002 Causal DAG Invariants
- RFC-0003 Shadow Working Sets
- RFC-0004 Materialized Head**
Start Date: 2025-11-28**
Target Spec: JITOS v0.x, TECHSPEC v0.3+**
---

# JIT RFC-0005

## The Inversion Engine Semantics (IES v1.0)

---

## 1. Summary

This RFC defines the Inversion Engine, the subsystem responsible for:

- collapsing a Shadow Working Set (SWS) into a deterministic snapshot node
- integrating subjective edits into the objective causal DAG
- resolving conflicts
- performing merges and rebases
- generating inversion-rewrite nodes
- preserving immutability and causal order
- producing the canonical next event in the universe

This subsystem is the computational analog of:

- quantum collapse
- observer synchronization
- relativistic frame merging
- provenance validation
- structural rewriting

Without the Inversion Engine, JIT cannot maintain truth.

---

## 2. Motivation

Shadow Working Sets represent subjective, isolated, locally consistent worldlines that agents operate within.

But the universe (the DAG) is singular.
Only one version of history exists.
Only one next event becomes real.

The Inversion Engine provides the laws and machinery that:

- merge subjective changes into objective truth
- reconcile divergent views
- enforce determinism
- preserve immutability
- maintain causal invariants

It is the OS kernel’s consistency layer, the physics engine’s update loop, the version-control system’s merge engine, and the distributed system’s truth arbitrator.

---

## 3. Definitions

### Inversion

A transformation where:
- the universe remains unchanged
- but a new node representing a rewrite, merge, or collapse is appended
- creating a new “view” of the past without modifying it

This is how rebases, merges, cherry-picks, and amends occur without violating immutability.

### Collapse

Application of the collapse operator:

```rust
collapse(sws, graph) → new_snapshot_node
```

### Rewrite Node

A node of type inversion-rewrite that expresses:

- `old-state → new-state` mapping
- causal relationships
- conflict resolutions
- structural transformations

---

## 4. Engine Responsibilities

The Inversion Engine MUST:

1. Anchor the SWS to its base node
2. Compare overlay graph against substrate
3. Detect conflicts
4. Derive minimal rewrite set
5. Validate all overlay nodes
6. Resolve divergences deterministically
7. Generate a new snapshot node
8. Emit an inversion-rewrite node if needed
9. Guarantee causal invariants
10. Finalize the collapse

Failure of any step MUST abort commit.

---

## 5. Collapse Algorithm (Formal)

Given:

- `base_node`
- `sws.overlay_nodes`
- `global_dag`

The engine MUST:

function collapse(sws, dag):

    1. verify $$base_node ∈ dag$$
    2. compute $$latest reality = dag.head(ref)$$
    3. if `base_node != latest reality`:
            `perform merge(base_node, latest reality)`
    4. apply overlays
    5. detect conflicts
    6. resolve conflicts deterministically
    7. compute final tree projection
    8. generate file-chunk nodes
    9. create new snapshot
   10. create inversion-rewrite node if merge occurred
   11. update DAG: append events
   12. destroy SWS
            `return new_snapshot_node`

All steps MUST be deterministic.

---

6. Merge Semantics

If the SWS’s base_node does NOT match the current ref head:

```rust
merge(base, head) → merged_structure
```

Merge MUST:

- preserve both lineages
- produce deterministic conflict sets
- apply Git-compatible merge strategy
- encode conflict data into rewrite node

After merging:

- MH updates for human users
- SWS virtual index updates for agents
- collapse continues

No merge ever mutates past events.
Merge produces new structures, not edits.

---

## 7. Conflict Semantics

Three kinds:

1. Structural conflicts
- file added in one world, deleted in another
2. Edit conflicts
- overlapping modifications
3. Semantic conflicts
- unsafe state transitions (runtime-defined)

Conflicts MUST be:

- detected deterministically
- resolved using canonical resolution order
- represented as multi-stage entries in MH
- returned to SWS for retry OR resolved via overlay

No conflict may EVER produce nondeterministic output.

---

8. Rewrite Nodes

If collapse involves a history divergence (merge/rebase/etc), the engine MUST produce a node:

```rust
InversionRewrite {
    parents: [old_nodes... new_nodes...]
    mapping: old → new
    merge_type: enum
    conflicts: optional data
    metadata: signatures, timestamps
}
```

This node:

- documents the transformation
- preserves immutability
- enables provenance
- maintains chronological truth

This is the mathematical identity of “rebase without rewriting history.”

---

## 9. Deterministic Rewrite Rules

The engine MUST guarantee:

- same SWS + same DAG → same output snapshot
- identical merges on different machines produce identical rewrite nodes
- collapse is a pure function
- no hidden state, randomness, or ordering bugs

This is vital for distributed correctness and replay.

---

## 10. Collapse Outcome

Collapse MUST produce exactly one:

- snapshot node (actual new state)
- optional inversion-rewrite node (if a merge/rewrite occurred)

Both MUST be appended to the DAG atomically.

Afterward:

- the SWS is destroyed
- MH updates
- refs update
- full invariants guaranteed

---

## 11. Legal Rewrites

Allowed:

- `merge`
- `rebase`
- `cherry-pick`
- `commit amend`
- `revert`
- `structural transforms` (future)
- `semantic rewrites` (future)

Forbidden:

- altering existing nodes
- deleting nodes
- modifying previous causal links

> [!DANGER]
> History never mutates.
> ***Ever.***
> *This is the core JIT philosophy.*

---

## 12. Inversion Engine Properties

The Inversion Engine MUST be:

### Deterministic

Pure function under fixed inputs.

### Idempotent

Repeated attempts produce identical graphs.

### Isolated

Engine state cannot bleed between collapses.

### Atomic

Collapse either fully commits or fully aborts.

### Serializable

Concurrent collapses resolve via causal ordering.

### Auditable

Every rewrite is represented in the DAG.

---

## 13. Security Considerations

The engine MUST:

- validate shadow provenance
- enforce signature rules
- reject malformed overlays
- reject inconsistent transformations
- reject illegal rewrites
- prevent history mutation attempts

Rewrite nodes MUST be cryptographically signed.

---

## 14. Why This Matters

The Inversion Engine is the literal physics of JIT.

It enforces:

- the arrow of time
- observer collapse
- causal consistency
- determinism
- worldline merging
- conflict locality
- immutability
- reproducibility
- truth maintenance

This subsystem is the soul of the Inversion Kernel.

Without it, the universe is chaos.
With it, the universe is computable.

---

## 15. Status & Next Steps

### Next RFC:

[RFC-0006](./RFC-0006.md) — WAL Format & Replay Semantics (The Temporal Backbone)

---

# **CΩMPUTER • JITOS** 
© 2025 James Ross • [Flying • Robots](https://flyingrobots.dev)
All Rights Reserved

