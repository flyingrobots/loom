---
Status: Draft**
Author: James Ross**
Contributors: JIT Community (future)**
Requires:
- RFC-0001 (Node Identity & Canonical Encoding)
- RFC-0002 (Causal DAG Invariants)**
Start Date: 2025-11-27**
Target Spec: JITOS v0.x, TECHSPEC v0.3+**
License: Open Source (TBD)**
---

# JIT RFC-0003 — Shadow Working Set Semantics (SWS v1.0)

## The Observer Model, Epistemic Isolation, and the Collapse Operator

---

1. Summary

This RFC defines the semantics of Shadow Working Sets (SWS) — the foundational abstraction for:

- agent-level processes
- parallel worldlines
- speculative computation
- observer-relative state
- distributed editing
- LLM/autonomous agent collaboration
- safe local mutation
- deterministic collapse into the global DAG

Shadow Working Sets represent local, subjective views of the universe — projections of the causal DAG — which remain isolated until resolved through a commit collapse event.

SWS is to JIT what “process” was to Unix —
except properly grounded in physics, causality, and distributed truth.

---

## 2. Motivation

Modern computation is multi-agent, distributed, asynchronous, and subject to the limits of:

- latency
- CAP theorem
- causality
- local knowledge
- observer frames

Traditional operating systems expose a global mutable filesystem, creating illusions of simultaneity and absolute state that are neither true nor safe.

JIT acknowledges physical and epistemic reality:

No agent ever sees the whole universe.
All views are subjective.
Reality is append-only.

Shadow Working Sets formalize this truth as a computational primitive.

---

3. Definition

A Shadow Working Set (SWS) is a temporary, isolated, agent-relative projection of the causal DAG.

It includes:

```rust
ShadowSet {
    id: uuid
    base_ref: string
    base_node: NodeID
    overlay_nodes: list<NodeID>
    virtual_tree_index: map<Path, NodeID>
    metadata: map<string,string>
}
```

- `base_node` = the snapshot node the Shadow branches from
- `overlay_nodes` = ephemeral nodes representing edits
- `virtual_tree_index` = projected filesystem view for the agent

All fields MUST be maintained in LMDB or equivalent.

---

## 4. Formal Semantics

Below are the rules governing SWS behavior.

---

### 4.1 SWS Isolated Worldline

An SWS is an epistemically isolated worldline which MUST NOT affect the global DAG until committed.

- overlays exist only within the SWS
- overlays cannot mutate the past
- overlays cannot commit without collapsing
- SWS cannot introduce new parents into the DAG

---

### 4.2 SWS Causal Anchoring

Each SWS MUST anchor to a single base node.

This ensures:

- deterministic diffs
- deterministic rewrite potential
- clear causal ancestry
- unambiguous commit behavior

The base node MUST be a valid snapshot node.

---

### 4.3 Local Consistency

Within an SWS:

- all edits must form a locally consistent graph
- overlay nodes MUST obey RFC-0001 and RFC-0002 invariants
- ordering must be deterministic within the SWS

Overlay graph is an internal micro-DAG, not merged with the global DAG.

---

### 4.4 No Cross-SWS Interference

Two SWS MUST NOT observe each other’s edits unless explicitly merged.

This enforces true agent isolation.

Agents operate in separate worldlines until collapse.

---

### 4.5 Subjective Filesystem Projection

SWS must maintain a virtual tree index for filesystem-like interactions.

This projection MUST be deterministic:

```rust
virtual_tree_index[path] = most recent overlay node OR inherited from base snapshot
```

No real files need exist; this is an in-memory projection.

---

### 4.6 Allowed Operations

Operations permitted inside an SWS:

- patch application
- diff computation
- linting
- refactoring
- build computations
- semantic agents (LLMs) modifying content
- structural rewrites
- preview merges
- pattern-matches for rewrites

These operations MUST NOT modify the global DAG.

---

## 5. Collapse Operator (Commit)

The commit is the most important concept:

Commit collapses a subjectively computed SWS into an objectively real DAG event.

The collapse operator:

```rust
collapse(sws, global_dag) → new_snapshot_node
```

Collapse MUST obey:

- determinism
- reproducibility
- inversion semantics (via Inversion Engine)
- causal ordering
- full validation of overlays
- merge conflict resolution
- topological soundness

Collapse also MUST:

- generate a new snapshot node
- discard the SWS afterward
- update the ref target
- log the event to WAL
- advance the universe

SWS death is required:

Once committed, a Shadow can no longer exist.
Potential becomes reality.
Superposition collapses into truth.

---

## 6. Merge & Conflict Semantics

If SWS collapse encounters divergence from `base_node`:

- the Inversion Engine MUST integrate changes
- conflicts MUST be represented as multi-stage entries
- merge MUST be deterministic
- if unresolvable, commit MUST fail

Conflicts do not mutate the global DAG.
They exist only during collapse evaluation.

---

## 7. Parallel Shadows

Multiple SWS may exist atop the same base_node or different base nodes.

Rules:

- parallel SWS are independent
- commit order provides serialization
- later SWS commit must resolve against updated reality
- deterministic merge rules must apply

This captures:

- concurrency
- distributed editing
- eventual consistency through collapse

---

## 8. Deletion & Failure Semantics

SWS MAY be:

- discarded by agent
- timed out
- destroyed by system
- invalidated by upstream commits

Invalidation MUST occur if:

- `base_node` no longer matches HEAD (or ref target)
- collapse produces inconsistency
- SWS violates invariants

In all cases:

Discarding an SWS must not affect the global DAG.

---

## 9. Lifecycle
	
### I.	Creation

```rust
shadow.create(ref)
```

Creates new SWS anchored to ref’s snapshot.

### II. Mutation

Edits accumulate in overlay nodes.

### III. Computation

Agents synthesize new states.

### IV. Collapse

```rust
shadow.commit(id)
```

Converts overlays → new snapshot.

### V. Death

SWS is destroyed.
Truth is updated.

---

## 10.  Security & Isolation

- SWS cannot tamper with DAG
- cannot impersonate global nodes
- cannot bypass collapse
- collapse validates signature/authorship
- each SWS owner is tracked in metadata

---

## 11. Why SWS Is Foundational

SWS solves:

- distributed agent concurrency
- local-only mutation
- parallel universes
- speculative worlds
- conflict-free workflows
- deterministic collapse
- reproducible builds
- multi-agent coordination
- physics-consistent computation

Without SWS, JIT would revert to Git-like semantics and lose the physics.

This RFC defines the heart of the inversion computation model.

---

## 12. Status & Next Steps

This RFC precedes:

- [RFC-0004](./RFC-0004.md) (Materialized Head)
- [RFC-0005](./RFC-0005.md) (Inversion Engine Semantics)
- [RFC-0006](./RFC-0006.md) (WAL Format & Replay)
- [RFC-0007](./RFC-0007.md) (JIT RPC API)
- [RFC-0008](./RFC-0008.md) (Message Plane Integration)

---

# **CΩMPUTER • JITOS** 
© 2025 James Ross • [Flying • Robots](https://flyingrobots.dev)
All Rights Reserved

