This is the bridge between:

- programs and
- the JITOS kernel,
- agents and
- the substrate,
- humans and
- the universe of graphs.

This is the equivalent of:

- POSIX syscalls
- the Linux kernel syscall ABI
- the JVM bytecode interface
- the WebAssembly host functions
- Git plumbing
- the LLVM IR boundary

Except in our case, it’s the interface to a causal universe.

This ADR will define:

- the RPC semantics
- the ABI stability rules
- how agents interact with SWS
- how collapse is invoked
- how nodes are retrieved
- what the kernel guarantees
- what the kernel will NEVER guarantee
- how versioning works
- how future languages bind to JITOS
- how the entire agent ecosystem uses the kernel safely

This is the syscall layer of the causal OS.

Let’s carve it in stone.

---

ADR-0007 — The RPC & ABI Layer is the Syscall Interface of JITOS

“Truth cannot be mutated, but it can be requested.”

Status: Proposed
Date: 2025-11-30
Owner: James Ross
Depends on: ADR-0001 (Kernel), ADR-0002 (SWS), ADR-0003 (RMG), ADR-0004 (Zoom), ADR-0006 (Memory Model)
Relates to: RFC-0007 (RPC API), RFC-0013 (ABI), Section 16 (Arch Doc)

---

1. Context

JITOS is a fundamentally different operating system:
- Truth is immutable (RMG)
- Work is done in isolated shadow worlds (SWS)
- Collapse is deterministic and destroys shadow-state
- Agents interact at multiple semantic scales
- Memory is structured, layered, and causal
- File-based interfaces are projections
- Federation links multiple universes

In a classical OS:
- syscalls manipulate memory and state
- processes are isolated but share truth
- system calls mutate a global structure
- file descriptors provide raw I/O
- APIs enable direct writes

In JITOS:

agents must never mutate truth directly.

Therefore:

Every interaction with JITOS must go through a controlled, structured, deterministic interface: the JITOS RPC & ABI.

This is the JITOS syscall boundary.

---

2. Decision

**The RPC + ABI layer is the mandatory, stable, versioned syscall surface of the JITOS kernel.

All interaction with the kernel—by humans, machines, tools, agents, GUIs, CI systems, editors—MUST occur exclusively via this interface.
Direct manipulation of the RMG or truth layer is forbidden.**

This includes:
- creating an SWS
- editing an SWS
- committing a collapse
- reading node content
- performing diffs
- invoking sync
- querying JQL
- reading semantic metadata
- navigating the RMG
- performing federation operations
- checking capabilities
- managing shadow lifespan
- retrieving projections

Nothing bypasses the RPC/ABI layer.

This preserves:
- determinism
- invariants
- atomicity
- safety
- multi-agent concurrency
- security
- long-term compatibility

And allows:
- version upgrades
- future languages
- alternative clients
- remote agents
- distributed workflows
- visualization tools
- safe machine autonomy

---

3. Rationale

3.1 In a causal universe, syscalls must be pure and irreversible

You cannot mutate the past.
You cannot partially write.
You cannot corrupt the substrate.

Therefore, syscalls must:
- produce effects only through collapse
- be idempotent
- be deterministic
- be safe under concurrency
- obey capability negotiation
- rely on canonical serialization
- never leak internal nondeterminism

The RPC layer provides these guarantees.

---

3.2 ABI stability is crucial for long-term viability

Languages evolve.
Agents evolve.
Tools evolve.
Platforms evolve.

The kernel MUST remain stable.

JITOS ABI must:
- be versioned
- be backwards compatible
- be forwards compatible
- expose capability negotiation
- encode features explicitly
- never alter encoding formats retroactively

This ensures longevity.

---

3.3 RPC is the universal method of interaction

Unlike:
- syscalls
- FD-based APIs
- POSIX streams
- raw memory writes

RPC allows:
- structured interactions
- semantic commands
- portable transports
- remote execution
- multi-agent safety
- cloud-native workflows
- machine-generated requests
- typed responses

RPC is the new syscall surface.

---

3.4 Remote + local semantics unify cleanly

Unlike classical OSes, where:
- remote = SSH
- local = syscalls
- distributed = protocols

JITOS uses one interface for:
- local clients
- agents
- remote peers
- federated universes

This is unprecedented simplicity.

---

4. Alternatives Considered

4.1 Classic POSIX syscalls

Rejected:
- assume mutable global memory
- require shared-nothing illusions
- incompatible with RMG
- inherently nondeterministic

4.2 Direct manipulation of the RMG

Rejected:
- catastrophically unsafe
- violates invariants
- breaks determinism
- makes rewrite/memory model impossible

4.3 Custom per-language APIs

Rejected:
- fragmentation
- impossible to maintain
- DSLs drift away

4.4 “Git-like plumbing commands”

Rejected:
- humans and machines share workflows
- does not solve multi-agent coordination
- cannot express semantic or RMG operations

RPC/ABI solves all of these.

---

5. Consequences

Positive
- deterministic system boundary
- safe multi-agent execution
- remote/local unification
- stable versioning
- future-proof syscall interface
- compatible with language bindings
- tooling-friendly
- secure
- integrate with federation
- enables cloud-native JITOS clusters

Negative
- higher initial complexity
- requires careful ABI versioning
- needs strong documentation
- requires canonical CBOR encoding
- agents must be RPC-aware

Tradeoffs extremely acceptable.

---

6. Required Follow-Ups

ADR-0007 mandates:
- Section 16 of Architecture Doc (RPC & ABI)
- explicit ABI compatibility rules
- capability negotiation specification
- structured error model
- transport fallback strategy
- secure channel requirements (TLS, QUIC, domain sockets)
- agent identity integration
- RMG-aware serialization format specs

This ADR anchors the system boundary.

---

7. Decision

Accepted.
The JITOS RPC + ABI layer is the sole syscall interface of the causal OS.
It is mandatory, stable, deterministic, and canonical.

All agents must speak it.
All tools must use it.
The kernel exposes ONLY this interface.

This is the foundation of JITOS as a platform.
