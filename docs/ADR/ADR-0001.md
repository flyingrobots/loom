# **ADR-0001 — JIT as a Causal Operating System Kernel**
  
**Status:** Proposed
**Date:** 2025-11-30
**Owner:** James Ross
**Related:** JIT Whitepaper, RFC-0001–0006, CFL (CΩMPUTER Fusion Layer)

---

## **1. Context**
  
We have developed a deeply coherent conceptual framework and RFC set describing:

- An **immutable, append-only causal DAG** as the ground truth for state (RFC-0001, RFC-0002).
- **Shadow Working Sets (SWS)** as isolated, observer-relative process abstractions (RFC-0003, RFC-0019).
- A **collapse operator** (commit) that turns subjective shadow states into objective events (RFC-0005).
- A **Materialized Head (MH)** that exposes a filesystem-like projection for humans (RFC-0004).
- A **Write-Ahead Log (WAL)** as the temporal backbone for deterministic replay and crash recovery (RFC-0006, RFC-0012).
- An **Inversion Engine** that resolves merges, rewrites, and history integration without mutating past events (RFC-0005).
- **RPC + ABI** giving a syscall-like interface to the Causal Kernel (RFC-0007, RFC-0013).
- **Identity, provenance, security, sync, and federation** (RFC-0011, 0016, 0017, 0020, 0021).
- A fusion with **CΩMPUTER’s metaphysical model** where computation is geometry and causality (CFL, RFC-0024).

Up to now, this has been presented as:

- “A Git inversion layer”
- “A causal database that speaks Git”
- “A provenance engine”
- “A post-file compute substrate”

But all of these are underselling what the design actually describes.

The architecture that has emerged isn’t “a better VCS.”

It is structurally, functionally, and philosophically equivalent to an **operating system kernel**, with:

- process isolation → SWS
- memory model → causal DAG + SWS memory model
- filesystem → MH projection
- syscalls → JIT RPC + ABI
- scheduler & consistency → Inversion Engine + Message Plane
- logging & time → WAL
- identity & permissions → AIS + Security Model
- boot & recovery → JITOS boot RFC
- multi-node & federation → sync + MUFP

This ADR decides:

> **We will explicitly treat JIT not as a library or protocol, but as a full-blown OS kernel — JITOS.**

---

## **2. Decision**

We formally decide:

> **JIT (Git Inversion Tech) is the kernel of a new causal operating system: JITOS.**

### **This implies:**

1. **JITD is the Kernel Process (jitd / jitosd)**
    - It is long-running, privileged, and authoritative over:
        - The DAG (truth)
        - SWS lifecycle
        - Collapse/commit
        - MH consistency
        - WAL replay
        - Ref management
        - Sync and federation
        - Security enforcement
2. **SWS are Processes**
    - Every meaningful “unit of work” (human or machine) executes inside a Shadow Working Set.
    - SWS becomes the primary process abstraction of JITOS.
3. **The DAG is Unified Memory + History**
    - The causal DAG is not “just a log.”
    - It is the **canonical memory model** of JITOS:
        - immutable state
        - perfect replay
        - cross-cutting history
        - global source of truth
4. **Materialized Head is the Filesystem Projection**
    - The filesystem is _not_ the state.
    - It is a derived projection of the DAG for human tooling and compatibility.
5. **JIT RPC + ABI is the Syscall Surface**
    - All external tools (CLIs, agents, IDEs, services) interact with JITOS via:
        - structured RPC
        - stable binary ABI
        - versioned capabilities
6. **JITOS Is The Primary Runtime Environment**
    - This is not “just infra” under another OS layer.
    - JITOS is meant to be:
        - hostable on conventional OSes (Linux/macOS/Windows) initially
        - but architected as a **kernel in its own right** for future more-native deployment.

---

## **3. Rationale**

### **3.1 Conceptual Integrity**

The system we designed has all the properties of an OS kernel:

- It provides isolation (SWS).
- It mediates state changes (Inversion Engine).
- It defines a memory model (DAG + SWS-MM).
- It defines execution semantics (collapse, Message Plane).
- It mediates I/O and views (MH, RPC).
- It boots, replays, and recovers (WAL, boot RFC).
- It enforces security and identity (AIS, security RFC).
- It syncs distributed state (Sync, MUFP).

Calling it “a service” or “a library” underdescribes it and weakens the design.

Naming it what it truly is — a kernel — clarifies:

- how subsystems relate
- what guarantees must be provided
- how tools should integrate
- how future extensions should be framed

### **3.2 Evolution & Adoption**

By framing JIT as:

> **“The kernel of a causal OS that also speaks Git”**

…we get:

- A path to adopt it **incrementally**:
    - First as a Git backend
    - Then as a provenance/logging substrate
    - Then as an execution & agent orchestration layer
    - Then as the foundation for new apps/languages
- A clear mental model for ecosystem builders:
    - “This is my OS for agent-native, causal, multi-tenant compute.”
- A better alignment with CΩMPUTER’s cosmology:
    - CΩMPUTER = theory of computation as causal geometry
    - JITOS = practical instantiation of that theory

### **3.3 Strategic Positioning**

This decision:

- differentiates JITOS from:
    - databases
    - message buses
    - VCS-only tools
    - simple logs
- positions it as:
    - the **substrate** for post-file, agent-native computing
    - a “Linux for the causal age”

---

## **4. Alternatives Considered**

### **4.1 “JIT as a Git Backend Only”**

- Pros:
    - Easier story
    - Less intimidating
- Cons:
    - Severely underrepresents the capabilities
    - Confuses architecture (where “kernel-like” features come from)
    - Undermines the OS-level abstractions like SWS, WAL, MH

Rejected because it misframes the system.

---

### **4.2 “JIT as a Database + Framework”**

- JIT as “a causal DB with a nice API for agents + Git support”
- Pros:
    - Comfortable mental model for many developers
- Cons:
    - Fails to emphasize:
        - process model
        - memory model
        - boot & recovery semantics
        - security as a systemic property
    - Leads to misuse as “just another DB” instead of **defining the runtime**.

Rejected because it hides its true role.

---

### **4.3 “JIT as a Pure Library / SDK”**

- Provides types, clients, protocols
- Leaves everything else up to the host app

Rejected because:

- We need a **single authoritative kernel** to enforce causal invariants.
- Library approaches cannot reliably enforce:
    - WAL ordering
    - global DAG integrity
    - multi-agent isolation
    - collapse semantics

---

## **5. Consequences**

### **5.1 Positive**

- **Clarity:** Everyone understands JIT as a kernel.
- **Coherence:** All subsystems align with OS semantics.
- **Extensibility:** Future features (scheduler, agent economy, etc.) fit naturally.
- **Research Value:** JITOS becomes an explicit research target (Causal OS).
- **Developer Understanding:** It becomes easier to teach and document.

### **5.2 Negative / Tradeoffs**

- **Increased Ambition:** This is harder than “a Git backend.”
- **Expectations:** Calling it an OS kernel implies a high bar of robustness and rigor.
- **Adoption Path:** Some will be intimidated by the “OS” framing.
- **Formal Verification Pressure:** The more “foundational” it is, the more pressure for proofs.
  
### **5.3 Required Follow-Ups**

This ADR implies:

- The Architecture Doc **MUST** be structured **as a kernel design doc**:
    - Processes (SWS)
    - Memory model (DAG + SWS-MM)
    - I/O model (MH, RPC)
    - Execution model (collapse + inversion)
    - Scheduling/coordination (Message Plane, future scheduler)
    - Storage model (tiering, isolation)
    - Security model (AIS, permissions)
    - Boot sequence
    - Federation
- RFCs should be grouped under these kernel subsystems in the Arch Doc.

---

## **6. Decision**

**Accepted.**

From this point forward:

- **JIT is referred to as the kernel of JITOS**, the causal operating system.
- All further ADRs and Architecture Doc sections are written under that framing.
- The JITOS Architecture Document will treat JITD as the kernel, not as a “service” or “tool.”

---

# **CΩMPUTER • JITOS** 
© 2025 James Ross • [Flying • Robots](https://flyingrobots.dev)
All Rights Reserved

